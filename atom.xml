<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JDD</title>
  <subtitle>Supsercell</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jddjj.github.io/"/>
  <updated>2016-03-30T02:06:47.732Z</updated>
  <id>http://jddjj.github.io/</id>
  
  <author>
    <name>Jidongdong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>InstantRun那些事</title>
    <link href="http://jddjj.github.io/2016/03/28/InstantRun%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://jddjj.github.io/2016/03/28/InstantRun那些事/</id>
    <published>2016-03-28T08:45:43.667Z</published>
    <updated>2016-03-30T02:06:47.732Z</updated>
    
    <content type="html">&lt;p&gt;　　刚入门的Android学员，现在应该还在玩转Eclipse，虽然现在大部分开发人员已经手持Android Studio ,但人们对新事物的接受总是需要缓冲的，并且有的人“恋旧”，并不是说不好，但是在技术更新迭代这么快的时代，不一定好，尝试总是没错的，你可以不做第一个吃螃蟹的人，但是有好多人说，螃蟹是美味的，那你就应该试试了。Android系统是由谷歌研发并维护，而作为谷歌推出的Android Studio 是自己个儿的亲儿子，广大开发人员不用去担心它的更新迭代是否被放弃。而现在的Android Studio已经进入2.0.0-beta6 版本，稳定性和扩展性已经非常强大，玩过Eclipse的都知道，经常会碰到缺少一些sdk的时候，这个时候我们就需要打开SDK Manager 去下载，这个界面大家一定很熟悉&lt;br&gt;&lt;img src=&quot;http://7xsffo.com1.z0.glb.clouddn.com/instantrun1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;  &lt;center&gt;&lt;strong&gt;&lt;em&gt;SDK Manager&lt;/em&gt;&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;               &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;，但是你有没有为下载过慢烦恼过，又找不到好的翻墙技巧，还有就是插件更新，经常需要去网络上下载离线包，查看各种教程去安装，还有用惯了Android Studio 感觉Eclipse界面好丑。这里并不是去贬低Eclipse，存在即合理，强大的扩展性和开源性，使其仍是开发Jsp，封装cocos2dx等得不可或缺的工具。并且现在仍有一些长久的项目，是eclipse开发的，应为项目过大并且已经成熟，并不适合迁移至Android Studio。      但是，对于以后从事Android开发，和新入门的同学，掌握Android Studio吧！你不会后悔的！说到这里，给大家附上一个链接，最新版本的Android开发相关工具都可以去这里下&lt;a href=&quot;http://www.androiddevtools.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AndroidDevTools&lt;/a&gt;;配置Android Studio方面就不进行赘述了，大家下载完可以去网上搜索很多好玩的插件，ButterKnife,CodeGlance,LifeSorter等等有助于编码的插件&lt;br&gt;&lt;img src=&quot;http://7xsffo.com1.z0.glb.clouddn.com/instantrun6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;&lt;em&gt;Android Studio Plugins&lt;/em&gt;&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;　　下面就是重点讲解下2.0版本一来，卖点最热的Instant Run，Instant Run 其实跟现如今流行的“HotFix”——热更新很像，它能实现让我们不需要重启App就能更新我们的修改，你是否还在为为了研究某个界面，改动之后必须重新运行，然后手动一个个跳转到你的研究界面上而不耐烦的等待呢？试试Instant Run吧！2.0.0从preview1到9 我都试过，更新版本之快基本隔三四天就是一个，直到现在比较稳定的2.0.0-beta6版本。期间经历过用Instant Run编译上一个版本构建的工程都报错的问题，经历过xml不提示双引号的bug,挺过来了，现在Instant Run下运行的状态&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://7xsffo.com1.z0.glb.clouddn.com/instantrun2.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;


&lt;p&gt;　　这个闪电符号就是我们开发效率提升的保证了，并且那个瓢虫样子的图标（Debug模式）也可以Instant Run。         我们要用Instant Run，首先要配置你的工程gradle plugin至2.0以后对应的版本，打开对应的ModuleSetting，将对应的配置设置到最新即可，如图&lt;br&gt;&lt;img src=&quot;http://7xsffo.com1.z0.glb.clouddn.com/instantrun5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;&lt;em&gt;配置&lt;/em&gt;&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;还有就是启用Instant Run 打开Setting&lt;br&gt;&lt;img src=&quot;http://7xsffo.com1.z0.glb.clouddn.com/instantrun4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;　　　　　　　　　　　　　　　&lt;center&gt;&lt;strong&gt;&lt;em&gt;配置&lt;/em&gt;&lt;/strong&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;　　好了，大功告成，你可以创建新的应用，或者直接按上述配置，配置好你曾经的应用，这样可以进行Instant Run了，比如说你改变了布局上的文字，直接再次点击闪电小图标，log控制台输出如下，说明你运行成功了，看看你的应用，没有重启吧，它只更新了当前Activity&lt;br&gt;&lt;img src=&quot;http://7xsffo.com1.z0.glb.clouddn.com/instantrun3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;　　　　　　　　　　　　　&lt;center&gt;&lt;strong&gt;&lt;em&gt;log控制台输出&lt;/em&gt;&lt;/strong&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt; 　　但是还有一些情况是不能支持Instant Run的，比如说AndroidManifest文件更改，R文件更改，添加了新的资源文件等等，但是你会发现，2.0版本仍然比以前运行快很多。所以不要注意这些细节，快来玩转吧。ps:有时候，由于项目过大，可能某些三方或者构建方面的修改导致不能运行Instant Run，比如我上次运用retrolambda,就不能在用Instant Run 了，但发现虽然需要重新启动应用程序，仍然很快，也就没有去调试是哪里的问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　刚入门的Android学员，现在应该还在玩转Eclipse，虽然现在大部分开发人员已经手持Android Studio ,但人们对新事物的接受总是需要缓冲的，并且有的人“恋旧”，并不是说不好，但是在技术更新迭代这么快的时代，不一定好，尝试总是没错的，你可以不做第一个吃螃蟹的人，但是有好多人说，螃蟹是美味的，那你就应该试试了。Android系统是由谷歌研发并维护，而作为谷歌推出的Android Studio 是自己个儿的亲儿子，广大开发人员不用去担心它的更新迭代是否被放弃。而现在的Android Studio已经进入2.0.0-beta6 版本，稳定性和扩展性已经非常强大，玩过Eclipse的都知道，经常会碰到缺少一些sdk的时候，这个时候我们就需要打开SDK Manager 去下载，这个界面大家一定很熟悉&lt;br&gt;&lt;img src=&quot;http://7xsffo.com1.z0.glb.clouddn.com/instantrun1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;  &lt;center&gt;&lt;strong&gt;&lt;em&gt;SDK Manager&lt;/em&gt;&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈回调接口</title>
    <link href="http://jddjj.github.io/2013/07/13/callback/"/>
    <id>http://jddjj.github.io/2013/07/13/callback/</id>
    <published>2013-07-13T12:46:25.000Z</published>
    <updated>2016-03-31T05:35:49.667Z</updated>
    
    <content type="html">&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;  有需求，才会去创造。&lt;br&gt;  网络上有许多关于接口回调的文章，各有千秋，理解角度也分别不同。今天本人希望从需求角度，能让一些对于接口回调不了解，或者概念模糊的人理解一下。本来是想写一下回调的概念。但是我发现这样不利于理解，所以这里我就不赘述概念了，大家看这篇博文也不要带着固定的思维去理解，希望大家举一反三吧。这里我从一个需求的角度让大家理解一下回调的逻辑流程。&lt;/p&gt;
&lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;  java中接口回调随处可见，比如说各种监听，onClickListener，而最近比较热的Mvp框架，其中view层抽象接口，也属于接口回调，掌握他，你会发现，逻辑世界还是很神奇的。&lt;br&gt;                                                                              &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;多线程之间数据同步问题&lt;br&gt; 更具象的说法，举个例子，我前段日子有个需求，我需要处理一些字段，但是这些字段里有一个值是北京时间，而北京时间是需要异步获取，这样我希望的就是获取到北京时间后，再处理。这里我就用了接口回调。  &lt;h1 id=&quot;流程示范&quot;&gt;&lt;a href=&quot;#流程示范&quot; class=&quot;headerlink&quot; title=&quot;流程示范&quot;&gt;&lt;/a&gt;流程示范&lt;/h1&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;编写功能模块&quot;&gt;&lt;a href=&quot;#编写功能模块&quot; class=&quot;headerlink&quot; title=&quot;编写功能模块&quot;&gt;&lt;/a&gt;编写功能模块&lt;/h2&gt;&lt;p&gt;&lt;code&gt;功能类A&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package com.dong.test;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @author JDD 这是一个功能类 假设他用来处理一些字段&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class ManageFields &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	String str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 * 用来处理字段的方法，而其中有一个字段是北京时间，需要开启异步线程获取时间后再进行一些逻辑处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void doSomething(String string) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//这里我需要获取北京时间，处理的话比如说拼接一段字段在北京时间前面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		 str = string;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//现在要获取北京时间，这个就是开启一个异步线程去获取，现在问题来了怎么获取它得到的异步时间并拼接起来的。这里就用到了回调&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		TimeUtil timeUtil = new TimeUtil();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		timeUtil.getBjTime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;功能类B&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
package com.dong.test;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.Date;

/**
 *
 * @author JDD 这个是个时间类 需要获取北京时间
 *
 */
public class TimeUtil {

    /**
     * 开启异步线程去获取时间
     */
    public void getBjTime() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                URL url;
                try {
                    url = new URL(&quot;http://www.baidu.com&quot;);
                    URLConnection uc = url.openConnection();// 生成连接对象
                    uc.connect(); // 发出连接
                    long ld = uc.getDate(); // 取得网站日期时间
                    Date date = new Date(ld); // 转换为标准时间对象
                    // 分别取得时间中的小时，分钟和秒，并输出
                    long bjTime = date.getTime();

                } catch (MalformedURLException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                } // 取得资源对象
                catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }).start();
    }

}
&lt;/code&gt;&lt;/pre&gt;
So 问题来了，该怎将获取的时间同步给A呢？这里大家可以发散一下思维，onclick事件，触发机制，也就是回调机制，它是完成点击(获取到时间后)，执行回调函数 onClick(view v)(执行处理操作)。那这里我们将回调时间抽象成接口。

## 编写接口 ##
调时间抽象成接口。

`抽象接口`
&lt;pre&gt;&lt;code&gt;
package com.dong.test;

/**
 *
 * @author JDD 时间回调接口 或者说就是监听时间获取
 *
 */
public interface TimeListener {
    //抽象方法，其中参数 就是获取到的时间
    void manageTime(long bjTime);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;改造模块实现回调&quot;&gt;&lt;a href=&quot;#改造模块实现回调&quot; class=&quot;headerlink&quot; title=&quot;改造模块实现回调&quot;&gt;&lt;/a&gt;改造模块实现回调&lt;/h2&gt;&lt;p&gt;首先时间获取模块B中应该有一个实现了TimeListener对象的引用，这里我们去重载一下其构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
package com.dong.test;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.Date;

/**
 *
 * @author JDD 这个是个时间类 需要获取北京时间
 *
 */
public class TimeUtil {

    TimeListener timeListener;
    /**
     * 这个是实现了TimeListener的对象的引用（其实就是ManageFileds的引用，这样就需要ManageFields类去实现接口）
     * @param timeListener
     */
    public TimeUtil(TimeListener timeListener){
        this.timeListener=timeListener;
    }

    /**
     * 开启异步线程去获取时间
     */
    public  void getBjTime() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                URL url;
                try {
                    url = new URL(&quot;http://www.baidu.com&quot;);
                    URLConnection uc = url.openConnection();// 生成连接对象
                    uc.connect(); // 发出连接
                    long ld = uc.getDate(); // 取得网站日期时间
                    Date date = new Date(ld); // 转换为标准时间对象
                    // 分别取得时间中的小时，分钟和秒，并输出
                    long bjTime = date.getTime();
                    //调用管理时间的接口
                    timeListener.returnTime(bjTime);

                } catch (MalformedURLException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                } // 取得资源对象
                catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }).start();
    }

}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;管理字段的类就需要实现 TimeListener接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
package com.dong.test;


/**
 *
 * @author JDD 这是一个功能类 假设他用来处理一些字段
 *
 */
public class ManageFields implements TimeListener {
    String str;
    /**
     * 用来处理字段的方法，而其中有一个字段是北京时间，需要开启异步线程获取时间后再进行一些逻辑处理
     */
    public void doSomething(String string) {
        // 这里我需要获取北京时间，处理的话比如说拼接一段字段在北京时间前面
         str = string;
        // 现在要获取北京时间，这个就是开启一个异步线程去获取，并将this，也就是自己的引用传过去
        TimeUtil timeUtil = new TimeUtil(this);
        timeUtil.getBjTime();
    }

    /**
     * 这里就是当异步线程获取到数据，调用timeListener.returnTime(bjTime)时，所回调的方法
     */
    @Override
    public void returnTime(long bjTime) {
        // TODO Auto-generated method stub
        System.out.println(str+bjTime);
    }
}



&lt;/code&gt;&lt;/pre&gt;


&lt;h2 id=&quot;测试代码&quot;&gt;&lt;a href=&quot;#测试代码&quot; class=&quot;headerlink&quot; title=&quot;测试代码&quot;&gt;&lt;/a&gt;测试代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;
package com.dong.test;

public class TestCallBack {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        ManageFields manageFields1=new ManageFields();
        ManageFields manageFields2=new ManageFields();

        manageFields1.doSomething(&quot;现在北京时间是：&quot;);
        manageFields2.doSomething(&quot;Now BeiJingTime is：&quot;);


    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;BeiJingTime is：1459396779000&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;现在北京时间是：1459396780000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;流程图&quot;&gt;&lt;a href=&quot;#流程图&quot; class=&quot;headerlink&quot; title=&quot;流程图&quot;&gt;&lt;/a&gt;流程图&lt;/h2&gt;&lt;p&gt;下面你有个大概思路了，我们看一下流程图（viso制作）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xsffo.com1.z0.glb.clouddn.com/callback1.png&quot; alt=&quot;流程图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;拓展&quot;&gt;&lt;a href=&quot;#拓展&quot; class=&quot;headerlink&quot; title=&quot;拓展&quot;&gt;&lt;/a&gt;拓展&lt;/h2&gt;&lt;p&gt;当然 管理字段类还可以写成大家熟知的匿名内部类形式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
package com.dong.test;

/**
 *
 * @author JDD 这是一个功能类 假设他用来处理一些字段
 *
 */
public class ManageFields implements TimeListener {
    String str;
        //匿名内部类实现
    public void doSomething(String string) {
        // 这里我需要获取北京时间，处理的话比如说拼接一段字段在北京时间前面
         str = string;
        // 现在要获取北京时间，这个就是开启一个异步线程去获取，并将this，也就是自己的引用传过去
        TimeUtil timeUtil = new TimeUtil(new TimeListener() {

            @Override
            public void returnTime(long bjTime) {
                // TODO Auto-generated method stub
                System.out.println(str+bjTime);
            }
        });
        timeUtil.getBjTime();
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;后话&quot;&gt;&lt;a href=&quot;#后话&quot; class=&quot;headerlink&quot; title=&quot;后话&quot;&gt;&lt;/a&gt;后话&lt;/h2&gt;&lt;p&gt;当然，你要是了解Rxjava,或者观察者模式，抑或hanlder等,都是可以实现这种需求的，但是，总有一种场景，有一种工具更配的来。就跟工具箱里的扳手一样，你有很多扳手，但是也有不同的螺丝，匹配的来的工具不是更给力么！&lt;br&gt;然而回调有时候不是必须的，因为有一个问题就是callbackhell-回调地狱，我的认知就是由于各种回调嵌套，导致工程可读性，可塑性差。所以大家也要两面性的看带问题！&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://7xsffo.com1.z0.glb.clouddn.com/TestCallBack.rar&quot; title=&quot;接口回调样例源码&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;接口回调样例源码&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;  有需求，才会去创造。&lt;br&gt;  网络上有许多关于接口回调的文章，各有千秋，理解角度也分别不同。今天本人希望从需求角度，能让一些对于接口回调不了解，或者概念模糊的人理解一下。本来是想写一下回调的概念。但是我发现这样不利于理解，所以这里我就不赘述概念了，大家看这篇博文也不要带着固定的思维去理解，希望大家举一反三吧。这里我从一个需求的角度让大家理解一下回调的逻辑流程。&lt;/p&gt;
&lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;  java中接口回调随处可见，比如说各种监听，onClickListener，而最近比较热的Mvp框架，其中view层抽象接口，也属于接口回调，掌握他，你会发现，逻辑世界还是很神奇的。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://jddjj.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://jddjj.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
